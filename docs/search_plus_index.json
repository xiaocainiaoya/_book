{"./":{"url":"./","title":"引言","keywords":"","body":" 日常积累 联系方式 日常积累 日常学习新技术的笔记 日常遇到问题的记录 日常使用便捷的工具 希望通过记录的方式，在过程中能有所积累，有所成长。 联系方式 email:987306440@qq.com Copyright © xiaocainiaoya.top 2021 all right reserved，powered by Gitbook最后修改时间 2021-03-11 20:12:59 "},"java/ThreadLocal/ThreadLocal.html":{"url":"java/ThreadLocal/ThreadLocal.html","title":"threadLocal","keywords":"","body":" ThreadLocal初探 一、ThreadLocal的实现原理 二、源码 1.set() 2.get() 三、继承性 四、内存泄漏 ThreadLocal初探 [TOC] 一、ThreadLocal的实现原理 ​ Thread有一个内部变量ThreadLocal.ThreadLocalMap,这个类是ThreadLocal的静态内部类，它的实现与HashMap类似，当线程第一次调用ThreadLocal的get/set方法时会初始化它。它的键是这个ThreadLocal对象本身，值是需要存储的变量。也就是说ThreadLocal类型的本地变量是存放在具体的线程空间里。当不断的使用get方法获取时，是到线程独有线程空间中获取变量，使得其他线程无法访问到，也就达到了线程安全的目的。在使用完成之后，可以通过remove方法，移除不使用的本地变量。 ThreadLocal和同步机制的比较 ​ 如果说同步机制是一种以时间换空间的做法，那么ThreadLocal就是一种以空间换时间的做法，在同步机制下，当访问共享变量时，同步机制保证了同一个时刻只能有一个线程访问到，其他线程进入阻塞。ThreadLocal下，为每个线程都复制了共享变量的副本，也就不存在共享变量的说法。 二、源码 1.set() 通过ThreadLocal的set方法调用到ThreadLocal.ThreadLocalMap静态内部类的set方法。 public class ThreadLocal { public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } // 若对象为空，则初始化threadLocalMap对象 void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } static class ThreadLocalMap { private void set(ThreadLocal key, Object value) { Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode & (len-1); // 先通过hashcode作为下标取数组对应位置的值，若为空，设置值。 // 若不为空，往后移动一个位置，如果获取到的长度等于数组长度，从0位置查找。 for (Entry e = tab[i];e != null;e = tab[i = nextIndex(i, len)]) { ThreadLocal k = e.get(); if (k == key) { e.value = value; return; } if (k == null) { replaceStaleEntry(key, value, i); return; } } tab[i] = new Entry(key, value); int sz = ++size; // 清除Entry对象还在，但是Entry的值为空的位置 && 当前数量是否大于容量 // 扩容 if (!cleanSomeSlots(i, sz) && sz >= threshold) rehash(); } // 这边的扩容有两个步骤 private void rehash() { //1. 重新排列table数组里的值，根据hashcode获取下标，若对应下标为空，则移动到该位置 // 若下标位置不为空，往后移动位置，直到找到空位置。 expungeStaleEntries(); // 2.排列的同时如果是空位置，会相应减少size，若排列之后的size仍然大于容量的3/4则扩容 if (size >= threshold - threshold / 4) // 两倍原长度扩容 resize(); } } } 2.get() public class ThreadLocal { public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; } } // 默认值 return setInitialValue(); } static class ThreadLocalMap { private Entry getEntry(ThreadLocal key) { int i = key.threadLocalHashCode & (table.length - 1); Entry e = table[i]; if (e != null && e.get() == key) return e; else return getEntryAfterMiss(key, i, e); } // 获取不到值有两种情况，e=null, e.get() == null,如果e=null直接返回null, // 如果e.get()=null，清除这个位置的值。 private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) { Entry[] tab = table; int len = tab.length; while (e != null) { ThreadLocal k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; } return null; } } } 三、继承性 ThreadLocal对父子线程也是一样，同样是不可相互访问。但是，在特殊情况下或许还是存在父子线程需要相互访问ThreadLocal中的值的业务需求。可以使用ThreadLocal的子类InheritableThreadLocal,它可以实现父子进程之间的变量获取。 /** InheritableThreadLocal继承ThreadLocal方法，并重写了三个方法，getMap、createMap方法 是为了让创建map和获取map的时候使用thread中的inheritableThreadLoca变量。而childValue 是为了在thread父进程调用init创建子进程时，创建子进程的inheritableThreadLocal的时候，逐 个拷贝父进程的nheritableThreadLocal值。 **/ public class InheritableThreadLocal extends ThreadLocal { protected T childValue(T parentValue) { return parentValue; } ThreadLocalMap getMap(Thread t) { return t.inheritableThreadLocals; } void createMap(Thread t, T firstValue) { t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue); } } public class Thread implements Runnable { private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) { if (name == null) { throw new NullPointerException(\"name cannot be null\"); } this.name = name; Thread parent = currentThread(); SecurityManager security = System.getSecurityManager(); if (g == null) { /* Determine if it's an applet or not */ /* If there is a security manager, ask the security manager what to do. */ if (security != null) { g = security.getThreadGroup(); } /* If the security doesn't have a strong opinion of the matter use the parent thread group. */ if (g == null) { g = parent.getThreadGroup(); } } /* checkAccess regardless of whether or not threadgroup is explicitly passed in. */ g.checkAccess(); /* * Do we have the required permissions? */ if (security != null) { if (isCCLOverridden(getClass())) { security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); } } g.addUnstarted(); this.group = g; this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); this.target = target; setPriority(priority); // 在这里拷贝 if (inheritThreadLocals && parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); this.stackSize = stackSize; tid = nextThreadID(); } } // threalLocal中根据threadLocalMap创建threadLocalMap private ThreadLocalMap(ThreadLocalMap parentMap) { Entry[] parentTable = parentMap.table; int len = parentTable.length; setThreshold(len); table = new Entry[len]; for (int j = 0; j key = (ThreadLocal) e.get(); if (key != null) { // 重写childChild方法 Object value = key.childValue(e.value); Entry c = new Entry(key, value); int h = key.threadLocalHashCode & (len - 1); while (table[h] != null) h = nextIndex(h, len); table[h] = c; size++; } } } } 四、内存泄漏 ​ ThreadLcal的引用关系如上如所示，虚线是使用软引用的地方。如果这个地方使用的是强引用，在业务代码中使用threadlocalInstance==null将ThreadLocalRef和ThreadLocal之间的强引用置空，value还是会通过另一条引用链currentThread->currentThread->map->entry->value到达，也是不会被GC掉。而若采用软引用，在系统将要发生内存溢出时会回收掉，也就是会断掉key与ThreadLocal之间的引用，使得key=null。 ​ 在ThreadLocal的实现中，为了避免内存泄漏已经做了很多安全性的控制，在get()和set()方法中都有相应的处理，通过特定的方式对存在key=null的脏Entry进行value=null的处理，使得value的引用链不可达。 为什么使用弱引用？ 一是尽管使用强引用也会出现内存泄漏，二是在ThreadLocal的生命周期中set、getEntry、remove里，都针对键为空的脏Entry进行处理。但是尽管如此，在编程过程中，形成一种良好的规范，在使用完ThreadLocal后都应该手动调用remove方法进行清理。 Copyright © xiaocainiaoya.top 2021 all right reserved，powered by Gitbook最后修改时间 2020-10-25 18:38:41 "},"java/ThreadLocal/InheritableThreadLocal.html":{"url":"java/ThreadLocal/InheritableThreadLocal.html","title":"InheritableThreadLocal","keywords":"","body":" InheritableThreadLocal 一、简介 二、实例 三、原理 1. InheritableThreadLocal的实现 2.线程的创建过程 四、思考 InheritableThreadLocal [TOC] 一、简介 ​ 在Thread中除了有属性threadLocals引用ThreadLocal.ThreadLocalMap，其实还有一个属性，也就是inheritableThreadLocals，threadLocals的作用是保存本地线程变量，而inneritableThreadLocals的作用是传递当前线程本地变量InheritableThreadLocal到子线程的本地变量InheritableThreadLocal中。 二、实例 public static void main(String[] args) throws InterruptedException { InheritableThreadLocal username = new InheritableThreadLocal<>(); ThreadLocal password = new ThreadLocal<>(); username.set(\"zhangShang\"); password.set(\"123456789\"); new Thread(new Runnable() { @Override public void run() { System.out.println(username.get()); System.out.println(password.get()); } }).start(); } 输出结果为： zhangShang null 所以基本上可以得出结论：InheritableThreadLocal是具有父子线程传递的，而ThreadLocal不具有父子线程传递的功能。 三、原理 1. InheritableThreadLocal的实现 InheritableThreadLocal继承于ThreadLocal，并重写了ThreadLocal中的三个方法。 public class InheritableThreadLocal extends ThreadLocal { /** * 这个接口是ThreadLocal的开放接口，默认实现是抛出UnsupportedOperationException异常。 * 实现上仅返回入参，调用上是在创建子线程时使用。 */ protected T childValue(T parentValue) { return parentValue; } /** * 重写getMap,操作InheritableThreadLocal时，将只会影响到线程对象Thread的 * inheritableThread属性。 */ ThreadLocalMap getMap(Thread t) { return t.inheritableThreadLocals; } /** * 与上面的获取方法getMap情况一致，创建时同理。 */ void createMap(Thread t, T firstValue) { t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue); } } 2.线程的创建过程 跟踪new Thread()方法。 1.进入初始化方法。 public Thread() { init(null, null, \"Thread-\" + nextThreadNum(), 0); } 2.调用init方法。 // 重载方法 private void init(ThreadGroup g, Runnable target, String name,long stackSize) { init(g, target, name, stackSize, null, true); } // 最后实际调用方法 private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) { if (name == null) { throw new NullPointerException(\"name cannot be null\"); } this.name = name; // parent线程为创建子线程的当前线程，也就是父线程。 Thread parent = currentThread(); ... 省略一些与本章无关代码 // inheritThreadLocals=true,默认值是true,且父线程的inheritableThreadLocal对象不为空 // 创建当前线程的inheritableThreadLocals对象。 if (inheritThreadLocals && parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); /* Stash the specified stack size in case the VM cares */ this.stackSize = stackSize; /* Set thread ID */ tid = nextThreadID(); } 3.进入创建方法createInheritedMap方法。 static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) { // 以父线程的inheritableThreadLocals为实例创建一个ThreadLocalMap对象 return new ThreadLocalMap(parentMap); } /** * 以父线程的inheritableThreadLocals为实例创建子线程的inheritableThreadLocals对象 * 实现上比较简单，将父线程的inheritableThreadLocals循环拷贝给子线程。 */ private ThreadLocalMap(ThreadLocalMap parentMap) { Entry[] parentTable = parentMap.table; int len = parentTable.length; setThreshold(len); table = new Entry[len]; for (int j = 0; j key = (ThreadLocal) e.get(); if (key != null) { // 至于这个地方为什么采用key.childValue(),内层的逻辑也仅仅是返回入参。 // 网上有些人说是为了减轻代码的阅读难度，笔者觉得有点牵强。感觉是为了在获取 // 过程中做一些小转换之类的？ Object value = key.childValue(e.value); Entry c = new Entry(key, value); int h = key.threadLocalHashCode & (len - 1); while (table[h] != null) h = nextIndex(h, len); table[h] = c; size++; } } } } 四、思考 ​ 上面说父子进程通过inheritableThreadLocals属性来传递本地变量，在实际的应用场景中，一般不会出现父进程直接创建子进程的情况，一般都是采用线程池的方式，如果采用线程池那么inheritableThreadLocal还会有效吗？读者可以考虑一下，写个demo跑一下，看看具体的情况，下一篇文章将进行解答。 Copyright © xiaocainiaoya.top 2021 all right reserved，powered by Gitbook最后修改时间 2020-10-25 20:05:04 "},"java/ThreadLocal/TransmittableThreadLocal.html":{"url":"java/ThreadLocal/TransmittableThreadLocal.html","title":"TransimittableThreadLocal","keywords":"","body":" TransmittableThreadLocal 一、背景 二、简介 三、基本使用 四、原理 TransmittableThreadLocal [TOC] 一、背景 ​ 上文说到父子线程传递本地变量可以通过InheritableThreadlocoal进行传递，但是如果采用线程池，不一定能传递，因为在线程在线程池中的存在不是每次使用都会进行创建，InheritableThreadlocal是在线程初始化时intertableThreadLocals=true才会进行拷贝传递。所以若本次使用的子线程是已经被池化的线程，从线程池中取出线下进行使用，是没有经过初始化的过程，也就不会进行父子线程的本地变量拷贝。 ​ 由于在日常应用场景中，绝大多数都是会采用线程池的方式进行资源的有效管理。目前知道的阿里有一个开源项目就是为了解决这个问题ThansmittableThreadLocal。 二、简介 ​ 在使用线程池等会池化复用线程的执行组件情况下，提供ThreadLocal值的传递功能，解决异步执行时上下文传递的问题。 ​ JDK的InheritableThreadLocal类可以完成父线程到子线程的值传递。但对于使用线程池等会池化复用线程的执行组件的情况，线程由线程池创建好，并且线程是池化起来反复使用的；这时父子线程关系的ThreadLocal值传递已经没有意义，应用需要的实际上是把 任务提交给线程池时的ThreadLocal值传递到 任务执行时。 ​ 本章主要介绍使用线程池场景下的问题，TransmittableThreadLocal还有很多其他的应用场景。传送门 三、基本使用 1.引入TransimittableThreadLocal依赖 com.alibaba transmittable-thread-local 2.11.5 2.简单使用 public static void main(String[] args) throws InterruptedException { // 创建线程池 ExecutorService executorService = Executors.newSingleThreadExecutor(); // 线程池经过TtlExecutors工具类包装，返回包装类ExecutorServiceTtlWrapper executorService = TtlExecutors.getTtlExecutorService(executorService); // 创建需要传递给线程池本地变量 TransmittableThreadLocal username = new TransmittableThreadLocal<>(); // 首次调用,这时候线程池中还未有线程，就算不使用TTL也可以通过InheritableThreadLocal获取到 // 父线程的本地变量。 username.set(\"zhangShang\"); executorService.submit(new Runnable() { @Override public void run() { System.out.println(username.get()); } }); // 第二次调用，由于使用的是单一线程的线程池，这时候是复用了上面创建的线程，所以这时通过 // inheritableThreadLocal是获取不到本地变量的。 Thread.sleep(3000); username.set(\"liSi\"); executorService.submit(new Runnable() { @Override public void run() { System.out.println(username.get()); } }); Thread.sleep(3000); username.set(\"wangWu\"); executorService.submit(new Runnable() { @Override public void run() { System.out.println(username.get()); } }); } 输出结果为: zhangShang liSi wangWu 四、原理 从定义来看，TransimittableThreadLocal继承于InheritableThreadLocal，并实现TtlCopier接口，它里面只有一个copy方法。所以主要是对InheritableThreadLocal的扩展。 public class TransmittableThreadLocal extends InheritableThreadLocal implements TtlCopier 在TransimittableThreadLocal中添加holder属性。这个属性的作用就是被标记为具备线程传递资格的对象都会被添加到这个对象中。要标记一个类，比较容易想到的方式，就是给这个类新增一个Type字段，还有一个方法就是将具备这种类型的的对象都添加到一个静态全局集合中。之后使用时，这个集合里的所有值都具备这个标记。 // 1. holder本身是一个InheritableThreadLocal对象 // 2. 这个holder对象的value是WeakHashMap, ?> // 2.1 WeekHashMap的value总是null,且不可能被使用。 // 2.2 WeekHasshMap支持value=null private static InheritableThreadLocal, ?>> holder = new InheritableThreadLocal, ?>>() { @Override protected WeakHashMap, ?> initialValue() { return new WeakHashMap, Object>(); } /** * 重写了childValue方法，实现上直接将父线程的属性作为子线程的本地变量对象。 */ @Override protected WeakHashMap, ?> childValue(WeakHashMap, ?> parentValue) { return new WeakHashMap, Object>(parentValue); } }; 应用代码是通过TtlExecutors工具类对线程池对象进行包装。工具类只是简单的判断，输入的线程池是否已经被包装过、非空校验等，然后返回包装类ExecutorServiceTtlWrapper。根据不同的线程池类型，有不同和的包装类。 @Nullable public static ExecutorService getTtlExecutorService(@Nullable ExecutorService executorService) { if (TtlAgent.isTtlAgentLoaded() || executorService == null || executorService instanceof TtlEnhanced) { return executorService; } return new ExecutorServiceTtlWrapper(executorService); } 进入包装类ExecutorServiceTtlWrapper。可以注意到不论是通过ExecutorServiceTtlWrapper#submit方法或者是ExecutorTtlWrapper#execute方法，都会将线程对象包装成TtlCallable或者TtlRunnable，用于在真正执行run方法前做一些业务逻辑。 /** * 在ExecutorServiceTtlWrapper实现submit方法 */ @NonNull @Override public Future submit(@NonNull Callable task) { return executorService.submit(TtlCallable.get(task)); } /** * 在ExecutorTtlWrapper实现execute方法 */ @Override public void execute(@NonNull Runnable command) { executor.execute(TtlRunnable.get(command)); } 所以，重点的核心逻辑应该是在TtlCallable#call()或者TtlRunnable#run()中。以下以TtlCallable为例，TtlRunnable同理类似。在分析call()方法之前，先看一个类Transmitter public static class Transmitter { /** * 捕获当前线程中的是所有TransimittableThreadLocal和注册ThreadLocal的值。 */ @NonNull public static Object capture() { return new Snapshot(captureTtlValues(), captureThreadLocalValues()); } /** * 捕获TransimittableThreadLocal的值,将holder中的所有值都添加到HashMap后返回。 */ private static HashMap, Object> captureTtlValues() { HashMap, Object> ttl2Value = new HashMap, Object>(); for (TransmittableThreadLocal threadLocal : holder.get().keySet()) { ttl2Value.put(threadLocal, threadLocal.copyValue()); } return ttl2Value; } /** * 捕获注册的ThreadLocal的值,也就是原本线程中的ThreadLocal,可以注册到TTL中，在 * 进行线程池本地变量传递时也会被传递。 */ private static HashMap, Object> captureThreadLocalValues() { final HashMap, Object> threadLocal2Value = new HashMap, Object>(); for(Map.Entry,TtlCopier>entry:threadLocalHolder.entrySet()){ final ThreadLocal threadLocal = entry.getKey(); final TtlCopier copier = entry.getValue(); threadLocal2Value.put(threadLocal, copier.copy(threadLocal.get())); } return threadLocal2Value; } /** * 将捕获到的本地变量进行替换子线程的本地变量，并且返回子线程现有的本地变量副本backup。 * 用于在执行run/call方法之后，将本地变量副本恢复。 */ @NonNull public static Object replay(@NonNull Object captured) { final Snapshot capturedSnapshot = (Snapshot) captured; return new Snapshot(replayTtlValues(capturedSnapshot.ttl2Value), replayThreadLocalValues(capturedSnapshot.threadLocal2Value)); } /** * 替换TransmittableThreadLocal */ @NonNull private static HashMap, Object> replayTtlValues(@NonNull HashMap, Object> captured) { // 创建副本backup HashMap, Object> backup = new HashMap, Object>(); for (final Iterator> iterator = holder.get().keySet().iterator(); iterator.hasNext(); ) { TransmittableThreadLocal threadLocal = iterator.next(); // 对当前线程的本地变量进行副本拷贝 backup.put(threadLocal, threadLocal.get()); // 若出现调用线程中不存在某个线程变量，而线程池中线程有，则删除线程池中对应的本地变量 if (!captured.containsKey(threadLocal)) { iterator.remove(); threadLocal.superRemove(); } } // 将捕获的TTL值打入线程池获取到的线程TTL中。 setTtlValuesTo(captured); // 是一个扩展点，调用TTL的beforeExecute方法。默认实现为空 doExecuteCallback(true); return backup; } private static HashMap, Object> replayThreadLocalValues(@NonNull HashMap, Object> captured) { final HashMap, Object> backup = new HashMap, Object>(); for (Map.Entry, Object> entry : captured.entrySet()) { final ThreadLocal threadLocal = entry.getKey(); backup.put(threadLocal, threadLocal.get()); final Object value = entry.getValue(); if (value == threadLocalClearMark) threadLocal.remove(); else threadLocal.set(value); } return backup; } /** * 清除单线线程的所有TTL和TL，并返回清除之气的backup */ @NonNull public static Object clear() { final HashMap, Object> ttl2Value = new HashMap, Object>(); final HashMap, Object> threadLocal2Value = new HashMap, Object>(); for(Map.Entry,TtlCopier>entry:threadLocalHolder.entrySet()){ final ThreadLocal threadLocal = entry.getKey(); threadLocal2Value.put(threadLocal, threadLocalClearMark); } return replay(new Snapshot(ttl2Value, threadLocal2Value)); } /** * 还原 */ public static void restore(@NonNull Object backup) { final Snapshot backupSnapshot = (Snapshot) backup; restoreTtlValues(backupSnapshot.ttl2Value); restoreThreadLocalValues(backupSnapshot.threadLocal2Value); } private static void restoreTtlValues(@NonNull HashMap, Object> backup) { // 扩展点，调用TTL的afterExecute doExecuteCallback(false); for (final Iterator> iterator = holder.get().keySet().iterator(); iterator.hasNext(); ) { TransmittableThreadLocal threadLocal = iterator.next(); if (!backup.containsKey(threadLocal)) { iterator.remove(); threadLocal.superRemove(); } } // 将本地变量恢复成备份版本 setTtlValuesTo(backup); } private static void setTtlValuesTo(@NonNull HashMap, Object> ttlValues) { for (Map.Entry, Object> entry : ttlValues.entrySet()) { TransmittableThreadLocal threadLocal = entry.getKey(); threadLocal.set(entry.getValue()); } } private static void restoreThreadLocalValues(@NonNull HashMap, Object> backup) { for (Map.Entry, Object> entry : backup.entrySet()) { final ThreadLocal threadLocal = entry.getKey(); threadLocal.set(entry.getValue()); } } /** * 快照类，保存TTL和TL */ private static class Snapshot { final HashMap, Object> ttl2Value; final HashMap, Object> threadLocal2Value; private Snapshot(HashMap, Object> ttl2Value, HashMap, Object> threadLocal2Value) { this.ttl2Value = ttl2Value; this.threadLocal2Value = threadLocal2Value; } } 进入TtlCallable#call()方法。 @Override public V call() throws Exception { Object captured = capturedRef.get(); if (captured == null || releaseTtlValueReferenceAfterCall && !capturedRef.compareAndSet(captured, null)) { throw new IllegalStateException(\"TTL value reference is released after call!\"); } // 调用replay方法将捕获到的当前线程的本地变量，传递给线程池线程的本地变量， // 并且获取到线程池线程覆盖之前的本地变量副本。 Object backup = replay(captured); try { // 线程方法调用 return callable.call(); } finally { // 使用副本进行恢复。 restore(backup); } } ​ 到这基本上线程池方式传递本地变量的核心代码已经大概看完了。总的来说在创建TtlCallable对象是，调用capture()方法捕获调用方的本地线程变量，在call()执行时，将捕获到的线程变量，替换到线程池所对应获取到的线程的本地变量中，并且在执行完成之后，将其本地变量恢复到调用之前。 Copyright © xiaocainiaoya.top 2021 all right reserved，powered by Gitbook最后修改时间 2020-10-25 23:46:14 "},"java/ThreadLocal/FastThreadLocal.html":{"url":"java/ThreadLocal/FastThreadLocal.html","title":"FastThreadLocal","keywords":"","body":" FastThreadLocal 一、背景 二、实例 三、原理 1.set值 2.get值 3.remove 四、总结 FastThreadLocal [TOC] 一、背景 ​ 因为需要，研究了可以通过InheritableThreadLocal进行父子线程中如何传递本地线程变量，通过阿里开源项目TransmitableThreadLocal进行进行线程池传递本地线程变量(详解可查看以往博客)。在查找资料的过程中无意发现了Dobbo的InternalThreadLocal，其实Dobbo的InternalThreadLocal和netty的FastThreadLocal有异曲同工之妙。之前学netty的时候有了解一点，为了加深一下ThreadLocal种群的了解，使用本博客记录一下。 二、实例 public static void main(String[] args) { /** * 原生线程调用方式 */ new Thread(new Runnable() { @Override public void run() { username.set(\"zhangSang\"); password.set(\"123456\"); password.remove(); System.out.println(username.get()); System.out.println(password.get()); } }).start(); /** * FastThreadLocalThread线程调用方式 */ new FastThreadLocalThread(new Runnable() { @Override public void run() { username.set(\"zhangSang\"); password.set(\"123456\"); System.out.println(username.get()); System.out.println(password.get()); } }).start(); } 单从运行结果看，都能获取到对应设置的值，二者没有任何输出区别，但是跟踪一下，可以看到调用的逻辑是有所区别的。 三、原理 ​ 熟悉ThreadLocal的应该知道，Threadlocal其实内部逻辑是一个以ThreadLocal对象为key，需要存储的值为value的map结构。而FastThreadLocal的内部实现是一个数组，实现上是直接通过下标定位元素，所以单纯从取、存的角度看，FastThreadLocal是比ThreadLocal高效。 ​ 对于使用原生线程Thread来说，其实最后是将数据存Thread.threadLocals(ThreadLocal.ThreadLocalMap)中,也就是说在这个线程所使用的所有FastThreadLocal最后都以 key=ThreadLocal 对象,value=InternalThreadLocalMap的方式存在线程ThreadLocal的一个节点中。而若使用的是netty封装的FastThreadLocalThread,则FastThreadLocalThread对象的属性threadLocalMap中。 ​ FastThreadLocalThread是直接继承于线程类Thread，并且内部维护一个InternalThreadLocalMap，用于存储变量。虽然这个类命名为Map，结构上其实是一个数组。并且下标为0的元素是一个Set>的结构，存储着当前有效的FastThreadLocal。 public class FastThreadLocalThread extends Thread{ private InternalThreadLocalMap threadLocalMap; } 在InternalThreadLocalMap中提供了一些静态方法，通过当前线程的不同类型，以不同的方式获取对应所需要的InternalThreadlocalMap。 /** * 获取方法 */ public static InternalThreadLocalMap get() { Thread thread = Thread.currentThread(); // 根据不同的线程类型，以不同的方式获取对应的InternalThreadLocalMap if (thread instanceof FastThreadLocalThread) { return fastGet((FastThreadLocalThread) thread); } else { return slowGet(); } } /** * FastThreadLocalThred获取方法 */ private static InternalThreadLocalMap fastGet(FastThreadLocalThread thread) { // 直接从FastThreadLocalThread对象中获取InternalThreadLocalMap InternalThreadLocalMap threadLocalMap = thread.threadLocalMap(); // 若为空,初始化一个InternalThreadLocalMap if (threadLocalMap == null) { thread.setThreadLocalMap(threadLocalMap = new InternalThreadLocalMap()); } return threadLocalMap; } /** * 原生线程的获取方法 */ private static InternalThreadLocalMap slowGet() { /** * 从UnpaddedInternalThreadLocalMap中获取到ThreadLocal * 在从ThreadLocal中获取InternalThreadLocalMap,若为空初始化一个。所以由此可知，原生线程 * 的FasstThreadLocal具体值，是以InternalThreadLocalMap为值，存储在ThreadLocal中。 */ ThreadLocal slowThreadLocalMap = UnpaddedInternalThreadLocalMap.slowThreadLocalMap; InternalThreadLocalMap ret = slowThreadLocalMap.get(); if (ret == null) { ret = new InternalThreadLocalMap(); slowThreadLocalMap.set(ret); } return ret; } 1.set值 public final void set(V value) { if (value != InternalThreadLocalMap.UNSET) { // 根据不同的线程类型，获取到的InternalThreadLocalMap进行设置值。 set(InternalThreadLocalMap.get(), value); } else { remove(); } } public final void set(InternalThreadLocalMap threadLocalMap, V value) { if (value != InternalThreadLocalMap.UNSET) { // 将需要存储的值添加到InternalThreadLocalMap对应的下标位置。 if (threadLocalMap.setIndexedVariable(index, value)) { addToVariablesToRemove(threadLocalMap, this); } } else { remove(threadLocalMap); } } private static void addToVariablesToRemove(InternalThreadLocalMap threadLocalMap, FastThreadLocal variable) { // 根据下标获取对应的元素 Object v = threadLocalMap.indexedVariable(variablesToRemoveIndex); Set> variablesToRemove; if (v == InternalThreadLocalMap.UNSET || v == null) { // 若为空，创建set结构并将值添加到对应的下标位置 variablesToRemove = Collections.newSetFromMap(new IdentityHashMap, Boolean>()); threadLocalMap.setIndexedVariable(variablesToRemoveIndex, variablesToRemove); } else { // 否则直接应用取出的值 variablesToRemove = (Set>) v; } // 添加元素到set集合中 variablesToRemove.add(variable); } 2.get值 public final V get() { return get(InternalThreadLocalMap.get()); } /** * get操作比较简单，直接从threadLocalMap获取对应的下标元素返回。 */ public final V get(InternalThreadLocalMap threadLocalMap) { Object v = threadLocalMap.indexedVariable(index); if (v != InternalThreadLocalMap.UNSET) { return (V) v; } return initialize(threadLocalMap); } /** * 是一个默认值操作，可以通过最后的initValue()会调用FastThreadLocal#initialValue * 做一个初始化的操作。 */ private V initialize(InternalThreadLocalMap threadLocalMap) { V v = null; try { v = initialValue(); } catch (Exception e) { PlatformDependent.throwException(e); } threadLocalMap.setIndexedVariable(index, v); addToVariablesToRemove(threadLocalMap, this); return v; } 3.remove public final void remove() { remove(InternalThreadLocalMap.getIfSet()); } @SuppressWarnings(\"unchecked\") public final void remove(InternalThreadLocalMap threadLocalMap) { if (threadLocalMap == null) { return; } // 删除对应下标值，赋值为UNSET占位符 Object v = threadLocalMap.removeIndexedVariable(index); //删除InternalThreadLocalMap[0]的Set>中的当前FastThreadLocal对象 removeFromVariablesToRemove(threadLocalMap, this); if (v != InternalThreadLocalMap.UNSET) { try { // 是一个增强，删除之后的业务逻辑，由子类实现，默认是空实现 onRemoval((V) v); } catch (Exception e) { PlatformDependent.throwException(e); } } } 四、总结 ​ FastThreadLocal实际上采用的是数组的方式进行存储数据，在数据的获取、赋值都是通过下标的方式进行，而ThreadLocal是通过map结构，先计算哈希值，在进行线性探测的方式进行定位。所以在高并发下，FastThreadLocal应该相对高效，但是FastThread有一个弊端就是index是一直累加，也就是说如果移除了某个变量是通过将对应下标的元素标记为UNSET占位，而不进行回收，会无限制增大，会触发扩容等一些问题。 Copyright © xiaocainiaoya.top 2021 all right reserved，powered by Gitbook最后修改时间 2020-10-27 22:33:17 "},"java/java的泛型.html":{"url":"java/java的泛型.html","title":"java泛型","keywords":"","body":" java的泛型 一、介绍 二、泛型方式 1. 泛型类 2.泛型接口 3.泛型方法 三、泛型擦除 1. 泛型数组 2.边界 四、常见问题 1. 基本数据类型不能作为类型参数 2.重载问题 3. 自限定的泛型 java的泛型 [TOC] 一、介绍 ​ 泛型实现了参数化参数化类型的概念，是代码可以应用于多种类型，设计的初衷应该是希望类或者方法能够具备最广泛的表达能力。在引入泛型之前，一般都是依赖于Object顶层对象实现类似泛型的功能，但是使用Object有一个缺陷是如果类型转换异常，编译器在编译期无法检测这种异常，只有在字节码的运行时期才会抛出类型转换异常。而JDK 1.5之后引入的泛型，在编译期就会对类型进行检查，使得问题可以及早发现。 二、泛型方式 1. 泛型类 泛型类的写法是在类上指明参数，并在属性或者方法中使用。 先来看一下在没有泛型之前的操作方式，采用Object的方式，使得调用点获取到这个对象，如果需要获取到对象自身实现的某个方法，就需要进行强制类型装换，所以可能会出现类型装换异常。 public static class Animal { private Object animal; public void set(Object animal){ this.animal = animal; } public Object get(){ return animal; } } 再泛型引入之后采用如下方式，调用点在通过get方法获取到对象时，直接是调用点设置的参数类型，所以无需进行强制类型转换。 public static class Animal { private T animal; public void set(T animal){ this.animal = animal; } public T get(){ return animal; } } 2.泛型接口 泛型也可以应用于接口，使用上与泛型类类似。 泛型接口对调用点来说有两种方式，一种是实现类指定了参数类型，则调用点无需再参数化类型；另一种是实现类依旧采用泛型的方式继承，则调用点就需要参数化类型。 public interface People { public T display(); } class Girl implements People{ public void display(String str){ System.out.println(\"display: \"+ str); } } class Boy implements People{ public void display(T t){ System.out.println(\"display:\"+t); } } 3.泛型方法 泛型也可以应用于方法上，并且这个方法对应的类可以是泛型类也可以不是泛型类。定义泛型方法只需要将泛型列表置于返回值之前。 class Test{ public void display(T t){ System.out.println(t); } } 显式的类型说明：对泛型方法的调用，可以显式的指明类型，语法是在点操作符与方法名之间插入尖括号，然后将类型置于尖括号中，这种方式广泛用于静态方法，使用tk.mybatis过都知道Example中创建的静态泛型方法，笔者刚开始进入公司写的时候都是按部就班，不知道泛型方法的具体逻辑，学了泛型才知道。 // ========= WeekendSqls ============ public class WeekendSqls implements SqlsCriteria { public static WeekendSqls custom() { return new WeekendSqls(); } } // 调用点 public static void main(String[] args) { WeekendSqls weekendSql = WeekendSqls.custom(); } 三、泛型擦除 java的泛型是使用擦除来实现的，所以在真正运行的时候，任何具体的类型都会被擦除，唯一知道的是，在使用某一对象，所以对以下例子而言，最后的输出结果为true，类型都为java.util.ArrayList public static void main(String[] args) { Class c1 = new ArrayList().getClass(); Class c2 = new ArrayList().getClass(); System.out.println(\"c1的类型为:\" + c1 + \"\\n\" + \"c2的类型为\" + c2); System.out.println( c1 == c2); } 1. 泛型数组 由于Class在运行时已经被擦除，实际的结果为Class，而通过这个没有指定类型Class的newInstance方法不会产生具体的结果。 public class ArrayMaker { private Class kind; public ArrayMaker(Class kind){ this.kind = kind; } T[] create(int size){ return (T[]) Array.newInstance(kind, size); } public static void main(String[] args) { ArrayMaker stringArrayMaker = new ArrayMaker<>(String.class); String[] stringArray = stringArrayMaker.create(9); // 这里的输出结果为 [null, null, null, null, null, null, null, null, null] System.out.println(Arrays.toString(stringArray)); } } 再看一个例子 public class ArrayOfGeneric { public static class Generic{} static final int SIZE = 100; // 在编译时期是Generic[]，在运行时期可以理解为Object[] static Generic[] gia; public static void main(String[] args) { // 编译时只会报警告，运行时会抛出类型装换异常，因为从Object[]转Generic[] // gia = (Generic[]) new Object[SIZE]; // 由于是Generic[]强转Object[]，所以运行正常。 gia = (Generic[]) new Generic[SIZE]; } } 再看一个更复杂一点的例子 public class GenericArray { private T[] array; private GenericArray(int size){ // 从编译器层面来说，创建数组强制装换为T[]，只会报警告 // 从运行层面来说，Object[]强制装换为Object[]，正常行为 array = (T[]) new Object[size]; } public void put(int index, T item){ array[index] = item; } public T[] rep(){ return array; } public static void main(String[] args) { GenericArray gai = new GenericArray<>(10); // 从编译器层面来说，获取到T[]赋值为Object[],正常行为 // 从运行层面来说，Object[]赋值为Object[]，正常行为 Object[] oa = gai.rep(); } } 通过以上的例子，在实际的编写代码中要考虑到编译器层面和运行层面，对编译器来说，需要保证类型的异常转换都在编译时期通过警告或者编译不通过的方式提示用户；对运行层面来说，由于参数化类型已经被擦除，有可能会导致出现类型转换异常。总之一句话，编译器在编译时就是尽可能的做类型检查，前置了异常的抛出时机，避免所有的类型转换异常都在运行时期抛出。 2.边界 2.1上界 泛型上界采用表示当前泛型参数只能由T类型的子类构成。 指明了这个泛型类参数化类型的参数的只能是T的子类，且会影响到泛型类中入参为参数化类型的方法。 class Food{} class Fruit extend Food{} class Apple extends Fruit {} class Orange extends Fruit{} class Plate{ private T item; public Plate(T t){item = t;} public void set(T t){item = t;} public T get(){return item;} } public static void main(String[] args) { Plate plate = new Plate<>(new Apple()); // 两个set方法均报错，由于限定了参数化类型的上界，而对于Fruit来说有很多子类 // 编译器在这时不知道应该使用哪个类来创建引用。 plate.set(new Apple()); plate.set(new Fruit()); Fruit f = plate.get(); // 报错，只能通过上界类获取引用 Apple a = plate.get(); } 2.2下界 泛型下界采用表示当前泛型的参数只能有T类型的父类构成。 指明了这个泛型类参数化类型的参数的只能是T的父类，且会影响到泛型类中返回值为参数化类型的方法。还是上面的例子 public static void main(String[] args) { Plate pf = new Plate<>(new Fruit()); // 由于限定参数类型为Fruit的超类，所以添加的元素只要是Fruit以及Fruit的 // 子类都会成功 pf.set(new Apple()); pf.set(new Fruit()); // 报错，由于限定参数为Fruit的超类，不能用Fruit来引用，当然了就算是Food也不行 Fruit ff = pf.get(); } 2.3无界(?通配符) ?称为无界通配符，表示的是一种未知类型，所以一般如果采用了?定义一个泛型，对其调用的是与具体类型无关的方法。最常用的应该是Class，因为就算是使用泛型Class也并没有依赖于T 如果看过jdk容器相关的源码，都应该知道在容器中有很多的方法都采用这种写法，即无需关心具体的类型。 public boolean containsAll(Collection c) { return c.isEmpty(); } ?表示的未知类型，相比于Object应该来说是一个更大的概念，所以List != List，并且List不能指向List的引用；而List可以指向List的引用。 但是有一点需要注意若List指向List之后，由于类型是未知的，所以List中使用泛型的方法都不能使用，也就是add(E e)不能使用，编译器报错；而remove(Object o)参数没有使用泛型，则可以使用。 List list = new ArrayList<>(); List objects = list; List objects = new ArrayList<>(); List list = objects; 2.4 小结 ​ 不论使用哪种边界，对于存在?来说，表示的都是未知类型，所以在使用上下界处理时要精准的知道类型之间的继承关系，上下界对入参参数化类型和返回值参数类型行为上的区别，并且在合适的场景可以进行添加操作，合适的场景可以进行获取操作。根据PECS(Producer Extends Consumer Super)原则，频繁读取操作，适合使用上界extends，频繁插入操作，适合使用下界Super。 2.5 不使用通过符?的上下界 形如或者是，这种方式在声明处就指定了参数化类型的值。 修改Plate类 static class Plate{ private T item; public Plate(T t){item = t;} public void set(T t){item = t;} public T get(){return item;} } public static void main(String[] args) { // 在声明处指定参数化类型的值 Plate pf = new Plate<>(new Apple()); pf.set(new Apple()); pf.set(new Fruit()); // 此处声明参数化类型的值为Apple Plate pa = new Plate<>(new Apple()); pa.set(new Apple()); // 编译报错，指定只能传入Apple对象 pa.set(new Fruit()); } 四、常见问题 1. 基本数据类型不能作为类型参数 ​ 在泛型中不能使用基本数据类型作为类型的参数，也就是不允许ArrayList的方式，只能通过java的自动装箱拆箱机制，使用ArrayList来实现。 2.重载问题 ​ 当出现多个参数化类型时，由于类型擦除的原因，重载的方法实际产生的是一样类型签名，所以不能产生不同类型的参数列表，必须提供明显有区别的方法名。 static class Plate{ private T item; private K key; public Plate(T t){item = t;} // 编译报错 public void set(T t){item = t;} public void set(K k){key = k;} public T get(){return item;} } 3. 自限定的泛型 自限定泛型强调的是创建这个类所使用的参数与这个类具有相同的类型。感觉有点绕，下面看一下java编程思想中的例子。 // 采用自限定声明 class SelfBounded> { T element; SelfBounded set(T arg) { element = arg; return this; } T get() { return element; } } /* * 自限定类型的使用就两种方式，就是以下两种方式。 * 1. 这边为了引入概念来说明，标记class之后的A为A1，尖括号中的A为A2 * 创建的这个类A1所使用的参数A2与这个类A1具有相同的类型。 */ class A extends SelfBounded {} /* * 2. 由于A已经继承了SelfBounded，所以B可以直接继承 */ class B extends SelfBounded {} // It's OK. class C extends SelfBounded { C setAndGet(C arg) { set(arg); return get(); } } class D {} // class E extends SelfBounded {} // [Compile error]: Type parameter D is not within its bound public class SelfBounding { public static void main(String[] args) { A a = new A(); a.set(new A()); a = a.set(new A()).get(); a = a.get(); C c = new C(); c = c.setAndGet(new C()); } } Enum的设计正是采用泛型自限定的方式。Enum的泛型限定了E的上界为Enum自身，确保了Enum的子类才能作为泛型参数，而在枚举中compareTo(E o)，在比较时，希望的是传入的参数类型就是Enum类型。所以这种设计使得方法中传入参数和返回的方法是与创建的类型保持继承关系，也就是说E extends Enum保证Enum的子类，比如StatusEnum枚举类都能够接收或者返回其本身。 public abstract class Enum> implements Comparable, Serializable Copyright © xiaocainiaoya.top 2021 all right reserved，powered by Gitbook最后修改时间 2021-03-12 18:41:46 "},"Spring/SpringBoot的jar包如何启动.html":{"url":"Spring/SpringBoot的jar包如何启动.html","title":"SpringBoot的jar包如何启动","keywords":"","body":" SpringBoot的jar包如何启动 一、简介 二、jar包的内部结构 三、加载过程 1.使用到的一些类 2.过程分析 四、总结 SpringBoot的jar包如何启动 @[toc] 一、简介 ​ 使用过SprongBoot打过jar包的都应该知道，目标文件一般都会生成两个文件，一个是以.jar的包，一个是.jar.original文件。那么使用SpringBoot会打出两个包，而.jar.original的作用是什么呢？还有就是java -jar是如何将一个SpringBoot项目启动，之间都进行了那些的操作？ ​ 其实.jar.original是maven在SpringBoot重新打包之前的原始jar包，内部只包含了项目的用户类，不包含其他的依赖jar包，生成之后，SpringBoot重新打包之后，最后生成.jar包，内部包含了原始jar包以及其他的引用依赖。以下提及的jar包都是SpringBoot二次加工打的包。 二、jar包的内部结构 SpringBoot打出的jar包，可以直接通过解压的方式查看内部的构造。一般情况下有三个目录。 BOOT-INF：这个文件夹下有两个文件夹classes用来存放用户类，也就是原始jar.original里的类；还有一个是lib，就是这个原始jar.original引用的依赖。 META-INF：这里是通过java -jar启动的入口信息，记录了入口类的位置等信息。 org:Springboot loader的代码，通过它来启动。 这里主要介绍一下/BOOT-INF/MANIFEST.MF文件 Manifest-Version: 1.0 Implementation-Title: springboot-server Implementation-Version: 0.0.1-SNAPSHOT Archiver-Version: Plexus Archiver Built-By: Administrator Implementation-Vendor-Id: cn.com.springboot Spring-Boot-Version: 1.5.13.RELEASE Implementation-Vendor: Pivotal Software, Inc. Main-Class: org.springframework.boot.loader.JarLauncher Start-Class: cn.com.springboot.center.AuthEenterBootstrap Spring-Boot-Classes: BOOT-INF/classes/ Spring-Boot-Lib: BOOT-INF/lib/ Created-By: Apache Maven 3.6.1 Build-Jdk: 1.8.0_241 Implementation-URL: http://projects.spring.io/spring-boot/auth-server/ Main-Class：记录了java -jar的启动入口，当使用该命令启动时就会调用这个入口类的main方法，显然可以看出，Springboot转移了启动的入口，不是用户编写的xxx.xxx.BootStrap的那个入口类。 Start-Class：记录了用户编写的xxx.xxx.BootStrap的那个入口类，当内嵌的jar包加载完成之后，会使用LaunchedURLClassLoader线程加载类来加载这个用户编写的入口类。 三、加载过程 1.使用到的一些类 3.1.1 Archive ​ 归档文件接口，实现迭代器接口，它有两个子类，一个是JarFileArchive对jar包文件使用，提供了返回这个jar文件对应的url、或者这个jar文件的MANIFEST文件数据信息等操作。是ExplodedArchive是文件目录的使用也有获取这个目录url的方法，以及获取这个目录下的所有Archive文件方法。 3.1.2 Launcher ​ 启动程序的基类，这边最后是通过JarLauncher#main()来启动。ExecutableArchiveLauncher是抽象类，提供了获取Start-Class类路径的方法，以及是否还有内嵌对应文件的判断方法和获取到内嵌对应文件集合的后置处理方法的抽象，由子类JarLauncher和WarLauncher自行实现。 3.1.3 Spring.loader下的JarFile和JarEntry ​ jarFile继承于jar.util.jar.JarFile，JarEntry继承于java.util.jar.JarEntry，对原始的一些方法进行重写覆盖。每一个JarFileArchive都拥有一个JarFile方法，用于存储这个jar包对应的文件，而每一个JarFile都有一个JarFileEntries,JarFileEntries是一个迭代器。总的来说，在解析jar包时，会将jar包内的文件封装成JarEntry对象后由JarFile对象保存文件列表的迭代器。所以JarFileArchive和JarFileEntries之间是通过JarFile连接，二者都可以获取到JarFile对象。 2.过程分析 从MANIFEST.MF文件中的Main-class指向入口开始。 创建JarLauncher并且通过它的launch()方法开始加载jar包内部信息。 public static void main(String[] args) throws Exception { new JarLauncher().launch(args); } JarLauncher的空构造方法时一个空实现，刚开始看的时候还懵了一下，以为是在后续的操作中去加载的文件，其实不然，在创建时由父类ExecutableArchiveLauncher的构造方法去加载的文件。 public ExecutableArchiveLauncher() { try { // 加载为归档文件对象 this.archive = createArchive(); } catch (Exception ex) { throw new IllegalStateException(ex); } } /** * 具体的加载方法 */ protected final Archive createArchive() throws Exception { ProtectionDomain protectionDomain = getClass().getProtectionDomain(); CodeSource codeSource = protectionDomain.getCodeSource(); URI location = (codeSource == null ? null : codeSource.getLocation().toURI()); String path = (location == null ? null : location.getSchemeSpecificPart()); if (path == null) { throw new IllegalStateException(\"Unable to determine code source archive\"); } File root = new File(path); if (!root.exists()) { throw new IllegalStateException( \"Unable to determine code source archive from \" + root); } // 判断路径是否是一个文件夹，是则返回ExplodedArchive对象，否则返回JarFileArchive return (root.isDirectory() ? new ExplodedArchive(root): new JarFileArchive(root)); } // ============== JarFileArchive ============= public class JarFileArchive implements Archive { public JarFileArchive(File file) throws IOException { this(file, null); } public JarFileArchive(File file, URL url) throws IOException { // 通过这个new方法创建JarFile对象 this(new JarFile(file)); this.url = url; } } // ============== JarFile ============= public class JarFile extends java.util.jar.JarFile { public JarFile(File file) throws IOException { // 通过RandomAccessDataFile读取文件信息 this(new RandomAccessDataFile(file)); } } jarLauncher#launch()方法： protected void launch(String[] args) throws Exception { // 注册URL协议的处理器，没有指定时，默认指向org.springframework.boot.loader包路径 JarFile.registerUrlProtocolHandler(); // 获取类路径下的归档文件Archive并通过这些归档文件的URL，创建线程上下文类加载器LaunchedURLClassLoader ClassLoader classLoader = createClassLoader(getClassPathArchives()); // 使用类加载器和用户编写的启动入口类，通过反射调用它的main方法。 launch(args, getMainClass(), classLoader); } JarLauncher的getClassPathArchives()是在ExecutableArchiveLauncher中实现: @Override protected List getClassPathArchives() throws Exception { List archives = new ArrayList( // 获取归档文件中满足EntryFilterg过滤器的项，isNestedArchive()方法由具体 // 的之类实现。 this.archive.getNestedArchives(new EntryFilter() { @Override public boolean matches(Entry entry) { return isNestedArchive(entry); } })); // 获取到当前归档文件下的所有子归档文件之后的后置操作，是一个扩展点。在JarLauncher // 中是一个空实现。 postProcessClassPathArchives(archives); return archives; } /** * JarLauncher的具体实现，这里通过判断是否在BOOT-INF/lib/包下返回true * 也就是说只会把jar包下的BOOT-INF/lib/下的文件加载为Archive对象 */ @Override protected boolean isNestedArchive(Archive.Entry entry) { if (entry.isDirectory()) { return entry.getName().equals(BOOT_INF_CLASSES); } return entry.getName().startsWith(BOOT_INF_LIB); } JarFileArchive的getNestedArchives方法 @Override public List getNestedArchives(EntryFilter filter) throws IOException { List nestedArchives = new ArrayList(); for (Entry entry : this) { // 若匹配器匹配获取内嵌归档文件 if (filter.matches(entry)) { nestedArchives.add(getNestedArchive(entry)); } } return Collections.unmodifiableList(nestedArchives); } protected Archive getNestedArchive(Entry entry) throws IOException { JarEntry jarEntry = ((JarFileEntry) entry).getJarEntry(); if (jarEntry.getComment().startsWith(UNPACK_MARKER)) { return getUnpackedNestedArchive(jarEntry); } try { // 根据具体的Entry对象，创建JarFile对象 JarFile jarFile = this.jarFile.getNestedJarFile(jarEntry); // 封装成归档文件对象后返回 return new JarFileArchive(jarFile); } catch (Exception ex) { throw new IllegalStateException(\"Failed to get nested entry\"+entry.getName(),ex); } } public synchronized JarFile getNestedJarFile(final ZipEntry entry)throws IOException { return getNestedJarFile((JarEntry) entry); } public synchronized JarFile getNestedJarFile(JarEntry entry) throws IOException { try { // 根据具体的Entry对象，创建JarFile对象 return createJarFileFromEntry(entry); } catch (Exception ex) { throw new IOException( \"Unable to open nested jar file'\"+entry.getName()+\"'\",ex); } } private JarFile createJarFileFromEntry(JarEntry entry) throws IOException { if (entry.isDirectory()) { return createJarFileFromDirectoryEntry(entry); } return createJarFileFromFileEntry(entry); } private JarFile createJarFileFromFileEntry(JarEntry entry) throws IOException { if (entry.getMethod() != ZipEntry.STORED) { throw new IllegalStateException(\"Unable to open nested entry '\" + entry.getName() + \"'. It has been compressed and nested \" + \"jar files must be stored without compression. Please check the \" + \"mechanism used to create your executable jar file\"); } // 获取到参数entry对应的RandomAccessData对象 RandomAccessData entryData = this.entries.getEntryData(entry.getName()); // 这里根据springboot扩展的url协议，在父路径的基础上添加!/来标记子包 return new JarFile(this.rootFile, this.pathFromRoot + \"!/\" + entry.getName(), entryData, JarFileType.NESTED_JAR); } 到这基本上读取jar内部信息，加载为对应归档文件对象的大概过程已经讲完了，接下来分析一下在获取到了整个jar的归档文件对象后的处理。 /** * 通过归档文件对象列表，获取对应的url信息，并通过url信息创建LaunchedURLClassLoader */ protected ClassLoader createClassLoader(List archives) throws Exception { List urls = new ArrayList(archives.size()); for (Archive archive : archives) { urls.add(archive.getUrl()); } return createClassLoader(urls.toArray(new URL[urls.size()])); } protected ClassLoader createClassLoader(URL[] urls) throws Exception { return new LaunchedURLClassLoader(urls, getClass().getClassLoader()); } 获取到对应的LaunchedUrlClassLoader类加载器之后，设置线程的上下文类加载器为该加载器。 protected void launch(String[] args, String mainClass, ClassLoader classLoader) throws Exception { Thread.currentThread().setContextClassLoader(classLoader); // 根据MANIFI.MF文件中的start-classs信息创建项目启动入口主类对象，并通过run方法启动 createMainMethodRunner(mainClass, args, classLoader).run(); } // =========== MainMethodRunner ================ public class MainMethodRunner { private final String mainClassName; private final String[] args; public MainMethodRunner(String mainClass, String[] args) { this.mainClassName = mainClass; this.args = (args == null ? null : args.clone()); } public void run() throws Exception { Class mainClass = Thread.currentThread().getContextClassLoader() .loadClass(this.mainClassName); // 通过反射调用启动项目启动类的main方法 Method mainMethod = mainClass.getDeclaredMethod(\"main\", String[].class); mainMethod.invoke(null, new Object[] { this.args }); } } 最后来说一下这个LaunchedURLClassLoader，它继承于URLClassLoader，并重写了loadClass方法 LaunchedClassLoader的loadClass方法 @Override protected Class loadClass(String name, boolean resolve)throws ClassNotFoundException { Handler.setUseFastConnectionExceptions(true); try { try { definePackageIfNecessary(name); } catch (IllegalArgumentException ex) { if (getPackage(name) == null) { throw new AssertionError(\"Package \" + name + \" has already been \" + \"defined but it could not be found\"); } } // 调用父类loadClass方法，走正常委派流程，最终会被LaunchURLClassLoader return super.loadClass(name, resolve); } finally { Handler.setUseFastConnectionExceptions(false); } } // ============URLClassLoader ===================== protected Class findClass(final String name)throws ClassNotFoundException { final Class result; try { result = AccessController.doPrivileged( new PrivilegedExceptionAction>() { public Class run() throws ClassNotFoundException { // 根据name，将路径转化为以.class结尾的/分隔的格式。 String path = name.replace('.', '/').concat(\".class\"); // 通过UrlClassPath对象根据路径获取资源类文件 Resource res = ucp.getResource(path, false); if (res != null) { try { return defineClass(name, res); } catch (IOException e) { throw new ClassNotFoundException(name, e); } } else { return null; } } }, acc); } catch (java.security.PrivilegedActionException pae) { throw (ClassNotFoundException) pae.getException(); } if (result == null) { throw new ClassNotFoundException(name); } return result; } 四、总结 ​ Springboot主要实现了对URL加载方式进行了扩展，并且对一些对象Archive、JarFile、Entry等进行了抽象和扩展，最后使用LaunchedUrlClassLoader来进行处理。 ​ Copyright © xiaocainiaoya.top 2021 all right reserved，powered by Gitbook最后修改时间 2020-11-08 14:40:11 "},"Spring/lombok的@SneakyThrows详解.html":{"url":"Spring/lombok的@SneakyThrows详解.html","title":"lombok的@SneakyThrows详解","keywords":"","body":" Lombok的@SneakyThrows详解 一、简介 二、原理 Lombok的@SneakyThrows详解 [TOC] 一、简介 ​ 在java的异常体系中Exception异常有两个分支，一个是运行时异常RuntimeException，一个是编译时异常，在Exception下的所有非RuntimeException异常，比如IOException、SQLException等；所有的运行时异常不捕获，编译时异常是一定要捕获，否则编译会报错。@SneakyThrows就是利用了这一机制，将当前方法抛出的异常，包装成RuntimeException，骗过编译器，使得调用点可以不用显示处理异常信息。 二、原理 /* * 若不使用@SneakyThrows注解，newInsstance方法会要求抛出InstantiationException, * IllegalAccessException异常，且调用sneakyThrowsTest()的地方需要捕获这些异常， * 加上@SneakyThrows注解之后就不需要捕获异常信息。 */ @SneakyThrows private void sneakyThrowsTest(){ SneakyThrowsDemo.class.newInstance(); } 如下为反编译之后的结果 private void sneakyThrowsTest() { try { HelloController.class.newInstance(); } catch (Throwable e) { // 调用Lombok方法转化为RuntimeException throw Lombok.sneakyThrow(e); } } // =========== ombok ========= public static RuntimeException sneakyThrow(Throwable t) { if (t == null) { throw new NullPointerException(\"t\"); } else { return Lombok.sneakyThrow0(t); } } /* * 这个方法是关键，这里对入参类型的约束为，而调用点将异常强转为 * RuntimeException */ private static T sneakyThrow0(Throwable t) throws T { throw (T)t; } 那么问题来了，为什么这个地方可以对原来的异常进行强转为RuntimeExcption？以下为直接强转的代码，显然运行之后报类型转换异常。 private void sneakyThrowsTest() { try { throw new Exception(); } catch (Throwable e) { // 直接将e强转为RuntimeException，运行到这里会报类型转换异常。 throw (RuntimeException)e; } } 实际上，这种做法是一种通过泛型欺骗了编译器，让编译器在编译期不报错(报警告)，而最后在JVM虚拟机中执行的字节码的并没有区别编译时异常和运行时异常，只有是不是和抛不抛异常而已。 Copyright © xiaocainiaoya.top 2021 all right reserved，powered by Gitbook最后修改时间 2021-03-12 18:42:11 "},"设计模式/从myBatis Plugin看责任链模式.html":{"url":"设计模式/从myBatis Plugin看责任链模式.html","title":"从mybatis Plugin看责任链模式","keywords":"","body":" 从myBatis Plugin看责任链模式 一、介绍 二、mybatis的责任链 三、过滤器相关责任链 四、总结 从myBatis Plugin看责任链模式 [TOC] 一、介绍 ​ 在mybatis中从sql的解析到最后结果集的返回，经过了一系列的内部组件，比如参数处理器parameterHandler，语句处理器StatementHandler，结果集处理器ResultSetHandler等。若开发者需要对SQL执行的某一环节进行一些特定的处理，比如参数类型的转换，数据分页功能，打印执行的SQL语句等都可以通过mybatis的插件机制实现。 二、mybatis的责任链 ​ mybatis中就是对内部的一个List数组做拦截，业务方通过实现Interceptor接口后，将具体的实现类通过InterceptorChain#addInterceptor添加到责任链中，当mybatis初始化资源时，会调用InterceptorChain#pluginAll通过代理的方式，将所有的插件通过逐层代理的方式将内部核心组件(比如ParameterHandler)包裹返回一个代理对象。 ​ 真正执行的地方是由于将内部核心组件都包装成了代理类，所以在调用执行方法时，会被代理对象拦截进入invoke方法，根据执行方法所属类以及注解等判断是否执行拦截器或者是执行原方法。 public interface Interceptor { /** * 拦截执行该方法 **/ Object intercept(Invocation invocation) throws Throwable; /** * 插入 **/ Object plugin(Object target); /** * 设置属性 **/ void setProperties(Properties properties); } public class InterceptorChain { /** * 内部就是一个拦截器的List */ private final List interceptors = new ArrayList(); public Object pluginAll(Object target) { //循环调用每个Interceptor.plugin方法 for (Interceptor interceptor : interceptors) { target = interceptor.plugin(target); } return target; } public void addInterceptor(Interceptor interceptor) { interceptors.add(interceptor); } public List getInterceptors() { return Collections.unmodifiableList(interceptors); } } 三、过滤器相关责任链 ​ 在权限校验等一些拦截器中，通常的做法是有多层拦截，比如简单的登录过程，先校验用户名密码是否正确，在校验是否拥有某项操作的操作权限之后才会使得用户获取到资源，但是如果用户名密码校验失败，就没有必要进入第二部的操作权限校验，所以这种场景下使用mybatis那种方式的责任链有所不妥。以下是基于在多层拦截下，若某层校验失败，直接拒绝继续往下校验的责任链模式。 /** * 拦截器接口 **/ public interface Filter { /** * 拦截执行方法 **/ Object doFilter(Object target, FilterChain filterChain); } /** * 具体实现A拦截 **/ class FilterA implements Filter{ @Override public Object doFilter(Object target, FilterChain filterChain){ System.out.println(\"A\"); // 在这里选择是否继续往下走，这种方式会往下走 return filterChain.doFilter(target); } } /** * 具体实现B拦截 **/ class FilterB implements Filter{ @Override public Object doFilter(Object target, FilterChain filterChain){ System.out.println(\"B\"); // 这种方式会直接返回，不会继续执行其他拦截器(当然了在我的例子中也没有其他拦截器了) return \"\"; } } /** * 内部维护一个数组，存储各个拦截器 **/ public static class FilterChain{ private List filters = new ArrayList<>(); private Iterator iterator; public Object doFilter(Object target){ if(iterator == null){ iterator = filters.iterator(); } if(iterator.hasNext()){ Filter filter = (Filter) iterator.next(); filter.doFilter(target, this); } return target; } public void addFilter(Filter filter){ filters.add(filter); } } /** * 测试 **/ public static void main(String[] args) { FilterChain filterChain = new FilterChain(); FilterA filterA = new FilterA(); FilterB filterB = new FilterB(); filterChain.addFilter(filterA); filterChain.addFilter(filterB); filterChain.doFilter(\"\"); } 四、总结 ​ 以上两种责任链的不同形式，其实是应对于不同的业务场景，当需要所有的拦截都走一轮，则采用第一种；当在某个拦截器失败后不继续进行，则采用第二种。在实际的场景中需要综合考虑，采取最符合业务场景的形式进行编码。 Copyright © xiaocainiaoya.top 2021 all right reserved，powered by Gitbook最后修改时间 2020-11-01 16:44:05 "},"设计模式/spring过滤器和拦截器.html":{"url":"设计模式/spring过滤器和拦截器.html","title":" SpringMVC中的过滤器和拦截器","keywords":"","body":" SpringMVC中的过滤器和拦截器 一、过滤器 二、拦截器 三、小结 SpringMVC中的过滤器和拦截器 [TOC] 一、过滤器 ​ 过滤器Filter是通过实现java.servlet.filter接口实现过滤器功能，作用是用于对传入的request和响应的response进行一些处理，比如对请求参数进行校验，或者设置、检验头部信息，再或者对一些非法行为进行校验。由实现的接口可知，过滤器是依赖于servlet容器。所以由于过滤器不依赖于spring容器，它也就无法获取到容器中的对象。 创建一个过滤器类继承java.servlet.filter接口，实现filter中的拦截方法。 package com.example.demo.modules.filter; import javax.servlet.*; import java.io.IOException; /** * @Description: * @date : 2020/6/9 */ public class MyFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { // 过滤器的具体执行方法 } @Override public void destroy() { } } 把创建的过滤器类加入过滤器链中 package com.example.demo.modules.filter; import org.springframework.boot.web.servlet.FilterRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.servlet.Filter; /** * 创建两个过滤器myFilter和myFilter2，并且分别添加到FilterRegistrationBean * @Description: * @date : 2020/6/9 */ @Configuration public class ConfigBean { @Bean public FilterRegistrationBean filterRegistrationBean(){ FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); filterRegistrationBean.setFilter(myFilter()); filterRegistrationBean.setName(\"myFilter\"); filterRegistrationBean.addUrlPatterns(\"/*\"); filterRegistrationBean.setOrder(1); //filterRegistrationBean.setInitParameters(); return filterRegistrationBean; } @Bean public FilterRegistrationBean filter2RegistrationBean(){ FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); filterRegistrationBean.setFilter(myFilter2()); filterRegistrationBean.setName(\"myFilter2\"); filterRegistrationBean.addUrlPatterns(\"/*\"); filterRegistrationBean.setOrder(2); //filterRegistrationBean.setInitParameters(); return filterRegistrationBean; } @Bean public Filter myFilter(){ return new MyFilter(); } @Bean public Filter myFilter2(){ return new MyFilter(); } } 二、拦截器 拦截器Interceptor是通过实现org.springframework.web.servlet包的HandlerInterceptor接口实现，这个接口是spring容器的接口，所以它是依赖于spring容器的。主要作用是AOP的思想，可以对某一个方法进行横切，做一些业务逻辑。 1.编写自定义拦截器类 package com.example.demo.modules.interceptor; import lombok.extern.slf4j.Slf4j; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * @Description: * @date : 2020/6/9 */ @Slf4j public class CustomHandlerInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception { log.info(\"请求调用之前\"); return false; } @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception { log.info(\"请求调用之后\"); } @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception { log.info(\"afterCompletion:请求调用完成后回调方法，即在视图渲染完成后回调\"); } } 2.注册自定义拦截器 package com.example.demo.modules.interceptor; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter; /** * 在spring2.0中WebMvcConfigurerAdapter已经过时，这里只是为了演示效果， * 有兴趣可以看下spring2.0中的WebMvcConfigurer * @Description: * @date : 2020/6/9 */ @Configuration public class WebMvcConfigurer extends WebMvcConfigurerAdapter { @Override public void addInterceptors(InterceptorRegistry registry) { //super.addInterceptors(registry); registry.addInterceptor(getHandlerInterceptor()).addPathPatterns(\"/*\"); } @Bean public static HandlerInterceptor getHandlerInterceptor(){ return new CustomHandlerInterceptor(); } } 过滤器和拦截器执行过程图 ​ 在请求到达容器前，进入Filter过滤器链，执行完过滤器链上每个Filter#doFilter()方法后，进入Servlet#service()方法，然后由dispatcher分发器将请求方法给对应映射成功的处理器controller，在进入controller具体方法之前，会被先进入Interceptor#preHandler()方法，然后再进入controller的具体返回，执行之后进入Interceptor#postHandler()这里主要是拦截了controller方法执行之后到返回的数据模型到达视图解析器之前，接着进入Interceptor#afterCompletion()方法，主要可以操作返回客户端之前的逻辑，最后返回到过滤链中各个Filter的调用点，可以处理返回到客户端的跳转等逻辑。 三、小结 ​ 过滤器是servlet中的接口，主要可以用于在请求进入到servlet之前拦截请求HttpServletRequest并根据需要进行一些检查等逻辑操作，也可以在HttpServletResponse返回到客户端之前进行一些逻辑操作。 ​ 拦截器是spring中的接口，所以它可以获取到spring中的一些bean和其他的一些资源，在面向切面编程中应用比较广，拦截其实就是一种AOP策略。 Copyright © xiaocainiaoya.top 2021 all right reserved，powered by Gitbook最后修改时间 2020-11-05 23:47:57 "}}